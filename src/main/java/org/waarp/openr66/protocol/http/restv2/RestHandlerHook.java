/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 * Copyright 2009, Waarp SAS, and individual contributors by the @author
 * tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 * All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see <http://www.gnu.org/licenses/>.
 */

package org.waarp.openr66.protocol.http.restv2;

import co.cask.http.HandlerHook;
import co.cask.http.HttpResponder;
import co.cask.http.internal.HandlerInfo;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;

import java.util.Arrays;
import java.util.List;

/** Hooks called before and after a request handler is called. */
public class RestHandlerHook implements HandlerHook {

    /** Message sent when the client does not accept the json format. */
    private final static String notAcceptable =
            "{\"userMessage\":\"Not acceptable\",\"internalMessage\":\"Client must accept JSON format.\"}";

    /** Message sent when the request content type is not valid for the specified request. */
    private final static String unsupportedMedia =
            "{\"userMessage\":\"Unsupported media\",\"internalMessage\":\"Request's content type must be %s.\"}";


    /**
     * Hook called before a request handler is called. Checks the request content type and accepted type. If the
     * accepted type is invalid, the httpResponder sends a code 415 response. If the content type is invalid, sends a
     * code 406 response. In both case the response will be sent immediately and the request handler won't be called.
     *
     * @param httpRequest   The request currently being processed.
     * @param httpResponder The responder to which response must be sent if need be.
     * @param handlerInfo   Information about the handler to which the request will be sent.
     * @return True if the request can be handed to the handler, False if an error occurred and a response must be
     * sent immediately.
     */
    @Override
    public boolean preCall(HttpRequest httpRequest, HttpResponder httpResponder, HandlerInfo handlerInfo) {
        if (httpRequest.method() != HttpMethod.DELETE && httpRequest.method() != HttpMethod.OPTIONS) {
            String contentType = null;
            if (httpRequest.headers().get(HttpHeaderNames.CONTENT_TYPE) != null) {
                contentType = httpRequest.headers().get(HttpHeaderNames.CONTENT_TYPE);
            }
            List<String> accept = null;
            if (httpRequest.headers().get(HttpHeaderNames.ACCEPT) != null) {
                accept = Arrays.asList(httpRequest.headers().get(HttpHeaderNames.ACCEPT).split(", *"));
            }

            boolean acceptJson = (accept == null || accept.contains(HttpHeaderValues.APPLICATION_JSON.toString()));
            boolean contentUrlForm = (contentType == null ||
                    contentType.equals(HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED.toString()));
            boolean contentJson = (contentType != null &&
                    contentType.equals(HttpHeaderValues.APPLICATION_JSON.toString()));

            if (!acceptJson) {
                httpResponder.sendJson(HttpResponseStatus.NOT_ACCEPTABLE, notAcceptable);
                return false;
            }
            if (httpRequest.method() == HttpMethod.GET) {
                if (!contentUrlForm) {
                    httpResponder.sendJson(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE,
                            String.format(unsupportedMedia, HttpHeaderValues.APPLICATION_X_WWW_FORM_URLENCODED));
                    return false;
                }
            } else if (!contentJson) {
                httpResponder.sendJson(HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE,
                        String.format(unsupportedMedia, HttpHeaderValues.APPLICATION_JSON));
                return false;
            }
        }

        return true;
    }

    /**
     * Hook called before a request handler is called.
     *
     * @param httpRequest        The request currently being processed.
     * @param httpResponseStatus The status of the http response generated by the request handler.
     * @param handlerInfo        Information about the handler to which the request was sent.
     */
    @Override
    public void postCall(HttpRequest httpRequest, HttpResponseStatus httpResponseStatus, HandlerInfo handlerInfo) {

    }
}
